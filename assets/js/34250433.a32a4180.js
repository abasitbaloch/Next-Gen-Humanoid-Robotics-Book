"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[451],{4056:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var s=t(4848),o=t(8453);const i={sidebar_position:5},r="Autonomous Behaviors",a={id:"module-4-vla/autonomous-behaviors",title:"Autonomous Behaviors",description:"Overview",source:"@site/docs/docs/module-4-vla/autonomous-behaviors.md",sourceDirName:"module-4-vla",slug:"/module-4-vla/autonomous-behaviors",permalink:"/docs/module-4-vla/autonomous-behaviors",draft:!1,unlisted:!1,editUrl:"https://github.com/abasitbaloch/Next-Gen-Humanoid-Robotics-Book/tree/main/docs/docs/module-4-vla/autonomous-behaviors.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Task Decomposition Systems",permalink:"/docs/module-4-vla/task-decomposition"},next:{title:"Human-Robot Interaction",permalink:"/docs/module-4-vla/human-robot-interaction"}},c={},l=[{value:"Overview",id:"overview",level:2},{value:"Behavior Architecture",id:"behavior-architecture",level:2},{value:"Behavior Trees",id:"behavior-trees",level:3},{value:"Leaf Nodes",id:"leaf-nodes",level:3},{value:"Navigation Behaviors",id:"navigation-behaviors",level:2},{value:"Waypoint Navigation",id:"waypoint-navigation",level:3},{value:"Obstacle Avoidance",id:"obstacle-avoidance",level:3},{value:"Manipulation Behaviors",id:"manipulation-behaviors",level:2},{value:"Grasping Behaviors",id:"grasping-behaviors",level:3},{value:"Perception-Action Behaviors",id:"perception-action-behaviors",level:2},{value:"Look and Act",id:"look-and-act",level:3},{value:"State Management",id:"state-management",level:2},{value:"Behavior State Machine",id:"behavior-state-machine",level:3},{value:"Safety and Monitoring",id:"safety-and-monitoring",level:2},{value:"Behavior Safety",id:"behavior-safety",level:3},{value:"Learning and Adaptation",id:"learning-and-adaptation",level:2},{value:"Behavior Learning",id:"behavior-learning",level:3},{value:"Integration with VLA Pipeline",id:"integration-with-vla-pipeline",level:2},{value:"Complete Integration",id:"complete-integration",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:2},{value:"Execution Monitoring",id:"execution-monitoring",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Solutions",id:"solutions",level:3},{value:"Next Steps",id:"next-steps",level:2}];function _(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"autonomous-behaviors",children:"Autonomous Behaviors"}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"This section covers autonomous behavior execution systems that enable humanoid robots to perform complex tasks without continuous human supervision. Autonomous behaviors are the culmination of perception, planning, and control systems working together to achieve high-level goals."}),"\n",(0,s.jsx)(n.h2,{id:"behavior-architecture",children:"Behavior Architecture"}),"\n",(0,s.jsx)(n.h3,{id:"behavior-trees",children:"Behavior Trees"}),"\n",(0,s.jsx)(n.p,{children:"Behavior trees provide a structured approach to autonomous behavior:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from enum import Enum\nfrom typing import List, Dict, Any, Optional\nimport time\n\nclass BehaviorStatus(Enum):\n    SUCCESS = "success"\n    FAILURE = "failure"\n    RUNNING = "running"\n    ERROR = "error"\n\nclass BehaviorNode:\n    def __init__(self, name: str):\n        self.name = name\n        self.status = BehaviorStatus.RUNNING\n        self.children: List[\'BehaviorNode\'] = []\n\n    def tick(self) -> BehaviorStatus:\n        """Execute one cycle of the behavior"""\n        raise NotImplementedError\n\n    def reset(self):\n        """Reset behavior state"""\n        self.status = BehaviorStatus.RUNNING\n\nclass CompositeNode(BehaviorNode):\n    def __init__(self, name: str):\n        super().__init__(name)\n\n    def add_child(self, child: \'BehaviorNode\'):\n        self.children.append(child)\n\nclass SequenceNode(CompositeNode):\n    """Execute children in sequence until one fails"""\n    def __init__(self, name: str):\n        super().__init__(name)\n        self.current_child_index = 0\n\n    def tick(self) -> BehaviorStatus:\n        while self.current_child_index < len(self.children):\n            child = self.children[self.current_child_index]\n            child_status = child.tick()\n\n            if child_status == BehaviorStatus.FAILURE:\n                self.current_child_index = 0\n                return BehaviorStatus.FAILURE\n            elif child_status == BehaviorStatus.RUNNING:\n                return BehaviorStatus.RUNNING\n            elif child_status == BehaviorStatus.SUCCESS:\n                self.current_child_index += 1\n\n        # All children succeeded\n        self.current_child_index = 0\n        return BehaviorStatus.SUCCESS\n\nclass SelectorNode(CompositeNode):\n    """Execute children until one succeeds"""\n    def __init__(self, name: str):\n        super().__init__(name)\n        self.current_child_index = 0\n\n    def tick(self) -> BehaviorStatus:\n        while self.current_child_index < len(self.children):\n            child = self.children[self.current_child_index]\n            child_status = child.tick()\n\n            if child_status == BehaviorStatus.SUCCESS:\n                self.current_child_index = 0\n                return BehaviorStatus.SUCCESS\n            elif child_status == BehaviorStatus.RUNNING:\n                return BehaviorStatus.RUNNING\n            elif child_status == BehaviorStatus.FAILURE:\n                self.current_child_index += 1\n\n        # All children failed\n        self.current_child_index = 0\n        return BehaviorStatus.FAILURE\n'})}),"\n",(0,s.jsx)(n.h3,{id:"leaf-nodes",children:"Leaf Nodes"}),"\n",(0,s.jsx)(n.p,{children:"Implement basic behavior actions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class ActionNode(BehaviorNode):\n    """Leaf node that performs an action"""\n    def __init__(self, name: str, action_func):\n        super().__init__(name)\n        self.action_func = action_func\n        self.start_time = None\n\n    def tick(self) -> BehaviorStatus:\n        if self.status == BehaviorStatus.RUNNING:\n            result = self.action_func()\n            if result is True:\n                return BehaviorStatus.SUCCESS\n            elif result is False:\n                return BehaviorStatus.FAILURE\n            else:\n                return BehaviorStatus.RUNNING\n        return self.status\n\nclass ConditionNode(BehaviorNode):\n    """Leaf node that checks a condition"""\n    def __init__(self, name: str, condition_func):\n        super().__init__(name)\n        self.condition_func = condition_func\n\n    def tick(self) -> BehaviorStatus:\n        result = self.condition_func()\n        return BehaviorStatus.SUCCESS if result else BehaviorStatus.FAILURE\n'})}),"\n",(0,s.jsx)(n.h2,{id:"navigation-behaviors",children:"Navigation Behaviors"}),"\n",(0,s.jsx)(n.h3,{id:"waypoint-navigation",children:"Waypoint Navigation"}),"\n",(0,s.jsx)(n.p,{children:"Implement autonomous navigation behaviors:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionClient\nfrom nav2_msgs.action import NavigateToPose\nfrom geometry_msgs.msg import PoseStamped\nfrom std_msgs.msg import String\n\nclass NavigationBehavior:\n    def __init__(self, node):\n        self.node = node\n        self.nav_client = ActionClient(node, NavigateToPose, 'navigate_to_pose')\n        self.status_publisher = node.create_publisher(String, 'behavior_status', 10)\n\n    def navigate_to_waypoint(self, x: float, y: float, theta: float = 0.0) -> bool:\n        \"\"\"Navigate to specified waypoint\"\"\"\n        goal_msg = NavigateToPose.Goal()\n        goal_msg.pose.header.frame_id = 'map'\n        goal_msg.pose.pose.position.x = x\n        goal_msg.pose.pose.position.y = y\n        goal_msg.pose.pose.position.z = 0.0\n        goal_msg.pose.pose.orientation.z = theta\n\n        self.nav_client.wait_for_server()\n        future = self.nav_client.send_goal_async(goal_msg)\n\n        # Wait for result with timeout\n        rclpy.spin_until_future_complete(self.node, future, timeout_sec=30.0)\n\n        if future.result() is not None:\n            return future.result().result\n        return False\n\nclass NavigationBehaviorNode(ActionNode):\n    def __init__(self, node, target_pose: Dict[str, float]):\n        self.nav_behavior = NavigationBehavior(node)\n        self.target_pose = target_pose\n        super().__init__(f\"navigate_to_{target_pose.get('name', 'unknown')}\", self._execute)\n\n    def _execute(self) -> bool:\n        \"\"\"Execute navigation action\"\"\"\n        success = self.nav_behavior.navigate_to_waypoint(\n            self.target_pose['x'],\n            self.target_pose['y'],\n            self.target_pose.get('theta', 0.0)\n        )\n        return success\n"})}),"\n",(0,s.jsx)(n.h3,{id:"obstacle-avoidance",children:"Obstacle Avoidance"}),"\n",(0,s.jsx)(n.p,{children:"Implement dynamic obstacle avoidance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class ObstacleAvoidanceBehavior:\n    def __init__(self, node):\n        self.node = node\n        self.laser_subscriber = node.create_subscription(\n            LaserScan, \'scan\', self.scan_callback, 10)\n        self.cmd_vel_publisher = node.create_publisher(Twist, \'cmd_vel\', 10)\n        self.obstacle_threshold = 0.5  # meters\n        self.avoidance_active = False\n\n    def scan_callback(self, msg: LaserScan):\n        """Process laser scan for obstacle detection"""\n        min_distance = min(msg.ranges)\n        if min_distance < self.obstacle_threshold:\n            self.trigger_avoidance()\n\n    def trigger_avoidance(self):\n        """Trigger obstacle avoidance behavior"""\n        if not self.avoidance_active:\n            self.avoidance_active = True\n            self.execute_avoidance()\n\n    def execute_avoidance(self):\n        """Execute obstacle avoidance maneuver"""\n        # Simple avoidance: turn away from obstacles\n        twist = Twist()\n        twist.angular.z = 0.5  # Turn to avoid\n        self.cmd_vel_publisher.publish(twist)\n\nclass AvoidanceBehaviorNode(ActionNode):\n    def __init__(self, node):\n        self.avoidance_behavior = ObstacleAvoidanceBehavior(node)\n        super().__init__("obstacle_avoidance", self._execute)\n\n    def _execute(self) -> bool:\n        """Execute obstacle avoidance"""\n        # This would typically run as a background behavior\n        return True  # Always succeeds as it runs continuously\n'})}),"\n",(0,s.jsx)(n.h2,{id:"manipulation-behaviors",children:"Manipulation Behaviors"}),"\n",(0,s.jsx)(n.h3,{id:"grasping-behaviors",children:"Grasping Behaviors"}),"\n",(0,s.jsx)(n.p,{children:"Implement autonomous manipulation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from control_msgs.action import FollowJointTrajectory\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\n\nclass ManipulationBehavior:\n    def __init__(self, node):\n        self.node = node\n        self.arm_controller = ActionClient(\n            node, FollowJointTrajectory, \'arm_controller/follow_joint_trajectory\')\n        self.gripper_controller = ActionClient(\n            node, FollowJointTrajectory, \'gripper_controller/follow_joint_trajectory\')\n\n    def grasp_object(self, object_pose: Dict[str, Any]) -> bool:\n        """Execute grasping behavior"""\n        # Move arm to pre-grasp position\n        pre_grasp_success = self.move_arm_to_pre_grasp(object_pose)\n        if not pre_grasp_success:\n            return False\n\n        # Execute grasp\n        grasp_success = self.execute_grasp(object_pose)\n        if not grasp_success:\n            return False\n\n        # Lift object\n        lift_success = self.lift_object()\n        return lift_success\n\n    def move_arm_to_pre_grasp(self, object_pose: Dict[str, Any]) -> bool:\n        """Move arm to position before grasp"""\n        # Calculate pre-grasp pose based on object pose\n        pre_grasp_pose = self.calculate_pre_grasp_pose(object_pose)\n\n        # Generate trajectory to pre-grasp pose\n        trajectory = self.generate_arm_trajectory(pre_grasp_pose)\n\n        return self.execute_arm_trajectory(trajectory)\n\n    def execute_grasp(self, object_pose: Dict[str, Any]) -> bool:\n        """Execute grasp action"""\n        # Move to grasp pose\n        grasp_pose = self.calculate_grasp_pose(object_pose)\n        trajectory = self.generate_arm_trajectory(grasp_pose)\n\n        if not self.execute_arm_trajectory(trajectory):\n            return False\n\n        # Close gripper\n        return self.close_gripper()\n\nclass GraspingBehaviorNode(ActionNode):\n    def __init__(self, node, object_info: Dict[str, Any]):\n        self.manipulation_behavior = ManipulationBehavior(node)\n        self.object_info = object_info\n        super().__init__(f"grasp_{object_info.get(\'name\', \'unknown\')}", self._execute)\n\n    def _execute(self) -> bool:\n        """Execute grasping behavior"""\n        return self.manipulation_behavior.grasp_object(self.object_info)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"perception-action-behaviors",children:"Perception-Action Behaviors"}),"\n",(0,s.jsx)(n.h3,{id:"look-and-act",children:"Look and Act"}),"\n",(0,s.jsx)(n.p,{children:"Combine perception and action:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from sensor_msgs.msg import Image, PointCloud2\nfrom cv_bridge import CvBridge\nimport cv2\nimport numpy as np\n\nclass PerceptionActionBehavior:\n    def __init__(self, node):\n        self.node = node\n        self.cv_bridge = CvBridge()\n\n        # Subscribers\n        self.image_subscriber = node.create_subscription(\n            Image, \'camera/image_raw\', self.image_callback, 10)\n        self.pointcloud_subscriber = node.create_subscription(\n            PointCloud2, \'pointcloud\', self.pointcloud_callback, 10)\n\n        # Data storage\n        self.current_image = None\n        self.current_pointcloud = None\n        self.last_detection_time = 0\n\n    def image_callback(self, msg: Image):\n        """Process incoming images"""\n        self.current_image = self.cv_bridge.imgmsg_to_cv2(msg, desired_encoding=\'bgr8\')\n\n    def pointcloud_callback(self, msg: PointCloud2):\n        """Process incoming point cloud"""\n        self.current_pointcloud = msg\n\n    def detect_and_approach_object(self, object_type: str) -> bool:\n        """Detect object and approach it"""\n        # Look for object\n        object_pose = self.look_for_object(object_type)\n\n        if object_pose is None:\n            self.node.get_logger().warn(f"Could not find {object_type}")\n            return False\n\n        # Navigate to object\n        approach_success = self.approach_object(object_pose)\n        return approach_success\n\n    def look_for_object(self, object_type: str) -> Optional[Dict[str, Any]]:\n        """Look for object in current view"""\n        if self.current_image is None:\n            return None\n\n        # Simple color-based detection (in practice, use more sophisticated methods)\n        if object_type == "red_cup":\n            return self.detect_red_object(self.current_image)\n        elif object_type == "green_bottle":\n            return self.detect_green_object(self.current_image)\n        else:\n            return self.detect_generic_object(self.current_image, object_type)\n\n    def detect_red_object(self, image: np.ndarray) -> Optional[Dict[str, Any]]:\n        """Detect red objects in image"""\n        # Convert to HSV for better color detection\n        hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n        # Define range for red color\n        lower_red = np.array([0, 50, 50])\n        upper_red = np.array([10, 255, 255])\n        mask1 = cv2.inRange(hsv, lower_red, upper_red)\n\n        # Red can also be at the high end of hue spectrum\n        lower_red = np.array([170, 50, 50])\n        upper_red = np.array([180, 255, 255])\n        mask2 = cv2.inRange(hsv, lower_red, upper_red)\n\n        mask = mask1 + mask2\n\n        # Find contours\n        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        if contours:\n            # Get largest contour (closest object)\n            largest_contour = max(contours, key=cv2.contourArea)\n            if cv2.contourArea(largest_contour) > 100:  # Minimum size threshold\n                # Calculate center of object\n                M = cv2.moments(largest_contour)\n                if M["m00"] != 0:\n                    cx = int(M["m10"] / M["m00"])\n                    cy = int(M["m01"] / M["m00"])\n\n                    return {\n                        \'x\': cx,\n                        \'y\': cy,\n                        \'contour\': largest_contour\n                    }\n\n        return None\n\nclass PerceptionActionBehaviorNode(ActionNode):\n    def __init__(self, node, object_type: str):\n        self.perception_action = PerceptionActionBehavior(node)\n        self.object_type = object_type\n        super().__init__(f"detect_and_approach_{object_type}", self._execute)\n\n    def _execute(self) -> bool:\n        """Execute perception-action behavior"""\n        return self.perception_action.detect_and_approach_object(self.object_type)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"state-management",children:"State Management"}),"\n",(0,s.jsx)(n.h3,{id:"behavior-state-machine",children:"Behavior State Machine"}),"\n",(0,s.jsx)(n.p,{children:"Manage behavior states and transitions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class BehaviorStateMachine:\n    def __init__(self):\n        self.current_state = "IDLE"\n        self.previous_state = None\n        self.state_start_time = time.time()\n        self.state_transitions = {}\n\n    def transition_to(self, new_state: str):\n        """Transition to new state"""\n        self.previous_state = self.current_state\n        self.current_state = new_state\n        self.state_start_time = time.time()\n\n        self.log_state_transition()\n\n    def log_state_transition(self):\n        """Log state transition for debugging"""\n        print(f"State transition: {self.previous_state} -> {self.current_state}")\n\n    def get_state_duration(self) -> float:\n        """Get time spent in current state"""\n        return time.time() - self.state_start_time\n\n    def update_state(self, sensor_data: Dict[str, Any]) -> str:\n        """Update state based on sensor data"""\n        # Define state transition logic\n        if self.current_state == "IDLE":\n            if sensor_data.get(\'command_received\'):\n                return "PLANNING"\n        elif self.current_state == "PLANNING":\n            if sensor_data.get(\'plan_ready\'):\n                return "EXECUTING"\n        elif self.current_state == "EXECUTING":\n            if sensor_data.get(\'execution_complete\'):\n                return "COMPLETED"\n            elif sensor_data.get(\'error_detected\'):\n                return "ERROR_HANDLING"\n        elif self.current_state == "ERROR_HANDLING":\n            if sensor_data.get(\'recovery_complete\'):\n                return "IDLE"\n\n        return self.current_state  # Stay in current state\n'})}),"\n",(0,s.jsx)(n.h2,{id:"safety-and-monitoring",children:"Safety and Monitoring"}),"\n",(0,s.jsx)(n.h3,{id:"behavior-safety",children:"Behavior Safety"}),"\n",(0,s.jsx)(n.p,{children:"Implement safety checks for autonomous behaviors:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class SafeBehaviorExecutor:\n    def __init__(self, node):\n        self.node = node\n        self.safety_limits = {\n            \'max_velocity\': 0.5,\n            \'max_force\': 50.0,\n            \'max_time\': 300,  # 5 minutes\n            \'max_current\': 10.0  # for actuators\n        }\n        self.emergency_stop_active = False\n        self.last_safe_check = time.time()\n\n    def execute_behavior_safely(self, behavior_tree: BehaviorNode) -> BehaviorStatus:\n        """Execute behavior with safety monitoring"""\n        start_time = time.time()\n\n        while not self.emergency_stop_active:\n            # Check safety constraints\n            if not self._check_safety_constraints():\n                self._trigger_emergency_stop()\n                return BehaviorStatus.ERROR\n\n            # Execute behavior tick\n            status = behavior_tree.tick()\n\n            # Check execution time\n            if time.time() - start_time > self.safety_limits[\'max_time\']:\n                self.node.get_logger().warn("Behavior exceeded maximum execution time")\n                return BehaviorStatus.FAILURE\n\n            if status != BehaviorStatus.RUNNING:\n                return status\n\n            # Small delay to prevent excessive CPU usage\n            time.sleep(0.05)\n\n        return BehaviorStatus.ERROR\n\n    def _check_safety_constraints(self) -> bool:\n        """Check all safety constraints"""\n        checks = [\n            self._check_velocity_limits(),\n            self._check_force_limits(),\n            self._check_current_limits(),\n            self._check_collision_avoidance()\n        ]\n\n        return all(checks)\n\n    def _check_velocity_limits(self) -> bool:\n        """Check velocity limits"""\n        # In practice, read current velocities from robot state\n        current_velocity = self._get_current_velocity()\n        return abs(current_velocity) <= self.safety_limits[\'max_velocity\']\n\n    def _check_force_limits(self) -> bool:\n        """Check force/torque limits"""\n        # In practice, read force/torque sensors\n        current_force = self._get_current_force()\n        return abs(current_force) <= self.safety_limits[\'max_force\']\n\n    def _trigger_emergency_stop(self):\n        """Trigger emergency stop"""\n        self.emergency_stop_active = True\n        self._publish_emergency_stop()\n\n    def _publish_emergency_stop(self):\n        """Publish emergency stop command"""\n        # Publish zero velocity commands to all controllers\n        pass\n'})}),"\n",(0,s.jsx)(n.h2,{id:"learning-and-adaptation",children:"Learning and Adaptation"}),"\n",(0,s.jsx)(n.h3,{id:"behavior-learning",children:"Behavior Learning"}),"\n",(0,s.jsx)(n.p,{children:"Implement learning mechanisms for autonomous behaviors:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class AdaptiveBehaviorLearner:\n    def __init__(self):\n        self.behavior_performance_history = {}\n        self.adaptation_rules = {}\n        self.learning_enabled = True\n\n    def record_behavior_outcome(self, behavior_name: str, outcome: Dict[str, Any]):\n        """Record outcome of behavior execution"""\n        if behavior_name not in self.behavior_performance_history:\n            self.behavior_performance_history[behavior_name] = []\n\n        self.behavior_performance_history[behavior_name].append(outcome)\n\n        # Check if adaptation is needed\n        if self._should_adapt(behavior_name):\n            self._adapt_behavior(behavior_name)\n\n    def _should_adapt(self, behavior_name: str) -> bool:\n        """Check if behavior needs adaptation"""\n        if behavior_name not in self.behavior_performance_history:\n            return False\n\n        recent_outcomes = self.behavior_performance_history[behavior_name][-5:]  # Last 5 attempts\n        failure_rate = sum(1 for outcome in recent_outcomes if not outcome.get(\'success\', False)) / len(recent_outcomes)\n\n        return failure_rate > 0.6  # Adapt if failure rate > 60%\n\n    def _adapt_behavior(self, behavior_name: str):\n        """Adapt behavior based on performance"""\n        # Implement adaptation logic\n        # This could involve:\n        # - Adjusting parameters\n        # - Changing strategy\n        # - Adding safety margins\n        # - Using different algorithms\n        pass\n\n    def get_adapted_behavior_params(self, behavior_name: str) -> Dict[str, Any]:\n        """Get adapted parameters for behavior"""\n        if behavior_name in self.adaptation_rules:\n            return self.adaptation_rules[behavior_name]\n        return {}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"integration-with-vla-pipeline",children:"Integration with VLA Pipeline"}),"\n",(0,s.jsx)(n.h3,{id:"complete-integration",children:"Complete Integration"}),"\n",(0,s.jsx)(n.p,{children:"Integrate autonomous behaviors with the VLA pipeline:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class VLAExecutionIntegrator:\n    def __init__(self, node, task_decomposer, behavior_executor):\n        self.node = node\n        self.task_decomposer = task_decomposer\n        self.behavior_executor = behavior_executor\n        self.adaptive_learner = AdaptiveBehaviorLearner()\n\n        # Publishers and subscribers\n        self.execution_status_publisher = node.create_publisher(\n            String, 'execution_status', 10)\n        self.execution_feedback_subscriber = node.create_subscription(\n            String, 'execution_feedback', self.feedback_callback, 10)\n\n        self.current_execution_id = None\n        self.execution_active = False\n\n    def execute_decomposed_task(self, decomposition: List[Dict]) -> Dict[str, Any]:\n        \"\"\"Execute decomposed task using autonomous behaviors\"\"\"\n        execution_start_time = time.time()\n        execution_results = []\n\n        for step in decomposition:\n            if not self.execution_active:\n                break\n\n            # Create behavior tree for this step\n            behavior_tree = self._create_behavior_tree(step)\n\n            # Execute behavior with safety monitoring\n            status = self.behavior_executor.execute_behavior_safely(behavior_tree)\n\n            # Record outcome for learning\n            outcome = {\n                'step_id': step['id'],\n                'status': status.value,\n                'success': status == BehaviorStatus.SUCCESS,\n                'execution_time': time.time() - execution_start_time\n            }\n            execution_results.append(outcome)\n\n            self.adaptive_learner.record_behavior_outcome(step['action'], outcome)\n\n            # Publish execution status\n            self._publish_execution_status(outcome)\n\n            if status == BehaviorStatus.FAILURE:\n                # Handle failure - maybe try alternative or stop\n                if not self._handle_step_failure(step, execution_results):\n                    break\n\n        execution_time = time.time() - execution_start_time\n\n        return {\n            'execution_id': self.current_execution_id,\n            'results': execution_results,\n            'overall_success': all(r['success'] for r in execution_results),\n            'execution_time': execution_time,\n            'steps_completed': len(execution_results)\n        }\n\n    def _create_behavior_tree(self, step: Dict[str, Any]) -> BehaviorNode:\n        \"\"\"Create behavior tree for a single step\"\"\"\n        action_type = step.get('action', 'unknown')\n        parameters = step.get('parameters', {})\n\n        if action_type == 'navigate':\n            return self._create_navigation_behavior(parameters)\n        elif action_type == 'grasp':\n            return self._create_grasping_behavior(parameters)\n        elif action_type == 'find_object':\n            return self._create_perception_behavior(parameters)\n        else:\n            return self._create_generic_behavior(step)\n\n    def feedback_callback(self, msg: String):\n        \"\"\"Handle execution feedback\"\"\"\n        try:\n            feedback_data = json.loads(msg.data)\n            self._process_execution_feedback(feedback_data)\n        except json.JSONDecodeError:\n            self.node.get_logger().error(f\"Invalid feedback JSON: {msg.data}\")\n\n    def _process_execution_feedback(self, feedback: Dict[str, Any]):\n        \"\"\"Process execution feedback for adaptation\"\"\"\n        if 'error' in feedback:\n            self._handle_execution_error(feedback)\n        elif 'success' in feedback:\n            self._record_success(feedback)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,s.jsx)(n.h3,{id:"execution-monitoring",children:"Execution Monitoring"}),"\n",(0,s.jsx)(n.p,{children:"Monitor behavior execution performance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class BehaviorPerformanceMonitor:\n    def __init__(self):\n        self.metrics = {\n            'execution_success_rate': [],\n            'execution_time': [],\n            'resource_usage': [],\n            'safety_incidents': []\n        }\n        self.start_times = {}\n\n    def start_monitoring(self, execution_id: str):\n        \"\"\"Start monitoring an execution\"\"\"\n        self.start_times[execution_id] = time.time()\n\n    def record_execution_result(self, execution_id: str, result: Dict[str, Any]):\n        \"\"\"Record execution result for analysis\"\"\"\n        execution_time = time.time() - self.start_times.get(execution_id, time.time())\n\n        self.metrics['execution_success_rate'].append(result.get('overall_success', False))\n        self.metrics['execution_time'].append(execution_time)\n\n        # Calculate success rate\n        success_rate = sum(self.metrics['execution_success_rate']) / len(self.metrics['execution_success_rate'])\n\n        return {\n            'success_rate': success_rate,\n            'avg_execution_time': sum(self.metrics['execution_time']) / len(self.metrics['execution_time']),\n            'total_executions': len(self.metrics['execution_success_rate'])\n        }\n\n    def get_performance_report(self) -> Dict[str, Any]:\n        \"\"\"Generate performance report\"\"\"\n        if not self.metrics['execution_success_rate']:\n            return {'message': 'No execution data available'}\n\n        return {\n            'success_rate': sum(self.metrics['execution_success_rate']) / len(self.metrics['execution_success_rate']),\n            'average_execution_time': sum(self.metrics['execution_time']) / len(self.metrics['execution_time']),\n            'total_executions': len(self.metrics['execution_success_rate']),\n            'safety_incidents': len(self.metrics['safety_incidents'])\n        }\n"})}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,s.jsx)(n.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Behavior oscillation"}),": Robot repeatedly switching between behaviors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource conflicts"}),": Multiple behaviors competing for resources"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Timing issues"}),": Behaviors not executing in proper sequence"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Safety violations"}),": Behaviors bypassing safety checks"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"solutions",children:"Solutions"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Priority systems"}),": Implement behavior priorities"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource management"}),": Coordinate resource usage"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Synchronization"}),": Properly sequence behavior execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Safety layers"}),": Multiple safety validation layers"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(n.p,{children:"Continue to the next section to learn about human-robot interaction systems that enable natural communication and collaboration between humans and humanoid robots."})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(_,{...e})}):_(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const o={},i=s.createContext(o);function r(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);