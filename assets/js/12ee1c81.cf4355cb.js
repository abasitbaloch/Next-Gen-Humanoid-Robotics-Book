"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[249],{7394:(n,i,e)=>{e.r(i),e.d(i,{assets:()=>r,contentTitle:()=>s,default:()=>p,frontMatter:()=>t,metadata:()=>o,toc:()=>c});var l=e(4848),a=e(8453);const t={sidebar_position:4},s="Manipulation and Control with Isaac",o={id:"module-3-ai-brain/manipulation-control",title:"Manipulation and Control with Isaac",description:"Overview",source:"@site/docs/docs/module-3-ai-brain/manipulation-control.md",sourceDirName:"module-3-ai-brain",slug:"/module-3-ai-brain/manipulation-control",permalink:"/docs/module-3-ai-brain/manipulation-control",draft:!1,unlisted:!1,editUrl:"https://github.com/abasitbaloch/Next-Gen-Humanoid-Robotics-Book/tree/main/docs/docs/module-3-ai-brain/manipulation-control.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Navigation and Path Planning with Isaac",permalink:"/docs/module-3-ai-brain/navigation-planning"},next:{title:"Synthetic Data Generation with Isaac",permalink:"/docs/module-3-ai-brain/synthetic-data"}},r={},c=[{value:"Overview",id:"overview",level:2},{value:"Manipulation System Architecture",id:"manipulation-system-architecture",level:2},{value:"Key Components",id:"key-components",level:3},{value:"Isaac Manipulation Tools",id:"isaac-manipulation-tools",level:3},{value:"Kinematics and Control",id:"kinematics-and-control",level:2},{value:"Forward and Inverse Kinematics",id:"forward-and-inverse-kinematics",level:3},{value:"Jacobian Computation",id:"jacobian-computation",level:3},{value:"Grasp Planning",id:"grasp-planning",level:2},{value:"Grasp Detection",id:"grasp-detection",level:3},{value:"Grasp Quality Assessment",id:"grasp-quality-assessment",level:3},{value:"Motion Planning",id:"motion-planning",level:2},{value:"Trajectory Generation",id:"trajectory-generation",level:3},{value:"Path Optimization",id:"path-optimization",level:3},{value:"Control Systems",id:"control-systems",level:2},{value:"Joint Space Control",id:"joint-space-control",level:3},{value:"Cartesian Space Control",id:"cartesian-space-control",level:3},{value:"Isaac Manipulation Packages",id:"isaac-manipulation-packages",level:2},{value:"Isaac Manipulator",id:"isaac-manipulator",level:3},{value:"GPU-Accelerated Planning",id:"gpu-accelerated-planning",level:3},{value:"Perception Integration",id:"perception-integration",level:2},{value:"Object Pose Estimation",id:"object-pose-estimation",level:3},{value:"Visual Servoing",id:"visual-servoing",level:3},{value:"Force Control",id:"force-control",level:2},{value:"Force/Torque Sensing",id:"forcetorque-sensing",level:3},{value:"Compliance Control",id:"compliance-control",level:3},{value:"Task and Motion Planning",id:"task-and-motion-planning",level:2},{value:"Task Planning Integration",id:"task-planning-integration",level:3},{value:"Multi-Step Manipulation",id:"multi-step-manipulation",level:3},{value:"Safety Considerations",id:"safety-considerations",level:2},{value:"Collision Avoidance",id:"collision-avoidance",level:3},{value:"Operational Limits",id:"operational-limits",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Real-time Performance",id:"real-time-performance",level:3},{value:"Computational Efficiency",id:"computational-efficiency",level:3},{value:"Testing and Validation",id:"testing-and-validation",level:2},{value:"Manipulation Testing",id:"manipulation-testing",level:3},{value:"Performance Metrics",id:"performance-metrics",level:3},{value:"Integration with Navigation",id:"integration-with-navigation",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Debugging Strategies",id:"debugging-strategies",level:3},{value:"Isaac-Specific Features",id:"isaac-specific-features",level:2},{value:"GPU Acceleration",id:"gpu-acceleration",level:3},{value:"Integration with Isaac Tools",id:"integration-with-isaac-tools",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(i.h1,{id:"manipulation-and-control-with-isaac",children:"Manipulation and Control with Isaac"}),"\n",(0,l.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,l.jsx)(i.p,{children:"This section covers robotic manipulation and control systems using NVIDIA Isaac tools. Manipulation is a key capability for humanoid robots, enabling them to interact with objects in their environment and perform complex tasks."}),"\n",(0,l.jsx)(i.h2,{id:"manipulation-system-architecture",children:"Manipulation System Architecture"}),"\n",(0,l.jsx)(i.h3,{id:"key-components",children:"Key Components"}),"\n",(0,l.jsx)(i.p,{children:"The manipulation system consists of several key components:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Motion Planning"}),": Path planning for manipulator arms"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Grasp Planning"}),": Determining how to grasp objects"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Control Systems"}),": Low-level joint control"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Perception Integration"}),": Object detection and pose estimation"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Task Planning"}),": High-level manipulation task decomposition"]}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"isaac-manipulation-tools",children:"Isaac Manipulation Tools"}),"\n",(0,l.jsx)(i.p,{children:"NVIDIA Isaac provides specialized manipulation tools:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Isaac Manipulator"}),": Manipulation planning and execution"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"GraspNet"}),": Deep learning-based grasp planning"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Motion Planning"}),": GPU-accelerated path planning"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Force Control"}),": Advanced force/torque control"]}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"kinematics-and-control",children:"Kinematics and Control"}),"\n",(0,l.jsx)(i.h3,{id:"forward-and-inverse-kinematics",children:"Forward and Inverse Kinematics"}),"\n",(0,l.jsx)(i.p,{children:"Implement kinematic solutions for manipulation:"}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-python",children:'import numpy as np\nfrom scipy.spatial.transform import Rotation as R\n\nclass ManipulatorKinematics:\n    def __init__(self, dh_parameters):\n        self.dh_params = dh_parameters\n\n    def forward_kinematics(self, joint_angles):\n        """Calculate end-effector pose from joint angles"""\n        # Implementation of forward kinematics\n        pass\n\n    def inverse_kinematics(self, target_pose):\n        """Calculate joint angles for target end-effector pose"""\n        # Implementation of inverse kinematics\n        pass\n'})}),"\n",(0,l.jsx)(i.h3,{id:"jacobian-computation",children:"Jacobian Computation"}),"\n",(0,l.jsx)(i.p,{children:"Compute Jacobian matrices for velocity control:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Task space velocities"}),"\n",(0,l.jsx)(i.li,{children:"Joint space velocities"}),"\n",(0,l.jsx)(i.li,{children:"Singularity detection"}),"\n",(0,l.jsx)(i.li,{children:"Redundancy resolution"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"grasp-planning",children:"Grasp Planning"}),"\n",(0,l.jsx)(i.h3,{id:"grasp-detection",children:"Grasp Detection"}),"\n",(0,l.jsx)(i.p,{children:"Detect graspable objects and suitable grasp points:"}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import PointCloud2\nfrom geometry_msgs.msg import PoseArray\n\nclass GraspPlannerNode(Node):\n    def __init__(self):\n        super().__init__('grasp_planner')\n        self.subscription = self.create_subscription(\n            PointCloud2,\n            'pointcloud_input',\n            self.pointcloud_callback,\n            10)\n        self.grasp_publisher = self.create_publisher(\n            PoseArray,\n            'candidate_grasps',\n            10)\n\n    def pointcloud_callback(self, msg):\n        # Process point cloud and detect grasp candidates\n        grasps = self.detect_grasps(msg)\n        self.publish_grasps(grasps)\n"})}),"\n",(0,l.jsx)(i.h3,{id:"grasp-quality-assessment",children:"Grasp Quality Assessment"}),"\n",(0,l.jsx)(i.p,{children:"Evaluate grasp quality metrics:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Force closure"}),"\n",(0,l.jsx)(i.li,{children:"Grasp stability"}),"\n",(0,l.jsx)(i.li,{children:"Object properties"}),"\n",(0,l.jsx)(i.li,{children:"Robot constraints"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"motion-planning",children:"Motion Planning"}),"\n",(0,l.jsx)(i.h3,{id:"trajectory-generation",children:"Trajectory Generation"}),"\n",(0,l.jsx)(i.p,{children:"Generate smooth, collision-free trajectories:"}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-yaml",children:"motion_planning:\n  trajectory_planner:\n    max_velocity: 0.5\n    max_acceleration: 1.0\n    max_jerk: 5.0\n    path_resolution: 0.01\n    collision_check_resolution: 0.005\n"})}),"\n",(0,l.jsx)(i.h3,{id:"path-optimization",children:"Path Optimization"}),"\n",(0,l.jsx)(i.p,{children:"Optimize trajectories for performance:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Minimum time trajectories"}),"\n",(0,l.jsx)(i.li,{children:"Minimum energy paths"}),"\n",(0,l.jsx)(i.li,{children:"Smoothness optimization"}),"\n",(0,l.jsx)(i.li,{children:"Dynamic constraints"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"control-systems",children:"Control Systems"}),"\n",(0,l.jsx)(i.h3,{id:"joint-space-control",children:"Joint Space Control"}),"\n",(0,l.jsx)(i.p,{children:"Implement joint space controllers:"}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-python",children:"class JointSpaceController:\n    def __init__(self, robot_model):\n        self.robot_model = robot_model\n        self.kp = np.diag([100.0, 100.0, 100.0, 50.0, 50.0, 50.0])  # Position gains\n        self.kd = np.diag([10.0, 10.0, 10.0, 5.0, 5.0, 5.0])      # Velocity gains\n\n    def compute_torques(self, q_desired, q_current, dq_desired, dq_current):\n        position_error = q_desired - q_current\n        velocity_error = dq_desired - dq_current\n\n        tau = self.kp @ position_error + self.kd @ velocity_error\n        return tau\n"})}),"\n",(0,l.jsx)(i.h3,{id:"cartesian-space-control",children:"Cartesian Space Control"}),"\n",(0,l.jsx)(i.p,{children:"Implement Cartesian space controllers:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Position control"}),"\n",(0,l.jsx)(i.li,{children:"Orientation control"}),"\n",(0,l.jsx)(i.li,{children:"Impedance control"}),"\n",(0,l.jsx)(i.li,{children:"Hybrid force/position control"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"isaac-manipulation-packages",children:"Isaac Manipulation Packages"}),"\n",(0,l.jsx)(i.h3,{id:"isaac-manipulator",children:"Isaac Manipulator"}),"\n",(0,l.jsx)(i.p,{children:"Use Isaac's manipulation packages:"}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-bash",children:"# Install Isaac Manipulator\nsudo apt install ros-humble-isaac-manipulator\n\n# Launch manipulation stack\nros2 launch isaac_manipulator manipulation.launch.py\n"})}),"\n",(0,l.jsx)(i.h3,{id:"gpu-accelerated-planning",children:"GPU-Accelerated Planning"}),"\n",(0,l.jsx)(i.p,{children:"Leverage GPU acceleration for manipulation planning:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Parallel trajectory evaluation"}),"\n",(0,l.jsx)(i.li,{children:"Accelerated collision checking"}),"\n",(0,l.jsx)(i.li,{children:"Real-time replanning"}),"\n",(0,l.jsx)(i.li,{children:"Multi-configuration planning"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"perception-integration",children:"Perception Integration"}),"\n",(0,l.jsx)(i.h3,{id:"object-pose-estimation",children:"Object Pose Estimation"}),"\n",(0,l.jsx)(i.p,{children:"Integrate perception for manipulation:"}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-python",children:'class PerceptionIntegrator:\n    def __init__(self):\n        self.object_poses = {}\n        self.grasp_points = {}\n\n    def update_object_poses(self, detection_results):\n        """Update object poses from perception system"""\n        for detection in detection_results:\n            self.object_poses[detection.id] = detection.pose\n            self.grasp_points[detection.id] = self.compute_grasp_points(detection)\n\n    def get_object_pose(self, object_id):\n        """Get current pose of an object"""\n        return self.object_poses.get(object_id)\n'})}),"\n",(0,l.jsx)(i.h3,{id:"visual-servoing",children:"Visual Servoing"}),"\n",(0,l.jsx)(i.p,{children:"Implement visual servoing for precise manipulation:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Image-based servoing"}),"\n",(0,l.jsx)(i.li,{children:"Position-based servoing"}),"\n",(0,l.jsx)(i.li,{children:"Hybrid approaches"}),"\n",(0,l.jsx)(i.li,{children:"Multi-camera systems"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"force-control",children:"Force Control"}),"\n",(0,l.jsx)(i.h3,{id:"forcetorque-sensing",children:"Force/Torque Sensing"}),"\n",(0,l.jsx)(i.p,{children:"Implement force control for safe manipulation:"}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-yaml",children:"force_control:\n  impedance_control:\n    stiffness:\n      translation: [1000.0, 1000.0, 1000.0]\n      rotation: [100.0, 100.0, 100.0]\n    damping_ratio: 1.0\n  force_limits:\n    max_force: 50.0\n    max_torque: 5.0\n    safety_factor: 0.8\n"})}),"\n",(0,l.jsx)(i.h3,{id:"compliance-control",children:"Compliance Control"}),"\n",(0,l.jsx)(i.p,{children:"Implement compliant behavior:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Variable impedance"}),"\n",(0,l.jsx)(i.li,{children:"Adaptive compliance"}),"\n",(0,l.jsx)(i.li,{children:"Contact transition handling"}),"\n",(0,l.jsx)(i.li,{children:"Safety limits"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"task-and-motion-planning",children:"Task and Motion Planning"}),"\n",(0,l.jsx)(i.h3,{id:"task-planning-integration",children:"Task Planning Integration"}),"\n",(0,l.jsx)(i.p,{children:"Integrate manipulation with task planning:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"High-level task decomposition"}),"\n",(0,l.jsx)(i.li,{children:"Motion planning for subtasks"}),"\n",(0,l.jsx)(i.li,{children:"Constraint satisfaction"}),"\n",(0,l.jsx)(i.li,{children:"Execution monitoring"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"multi-step-manipulation",children:"Multi-Step Manipulation"}),"\n",(0,l.jsx)(i.p,{children:"Plan complex manipulation sequences:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Pick-and-place operations"}),"\n",(0,l.jsx)(i.li,{children:"Multi-object manipulation"}),"\n",(0,l.jsx)(i.li,{children:"Tool use"}),"\n",(0,l.jsx)(i.li,{children:"Assembly tasks"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"safety-considerations",children:"Safety Considerations"}),"\n",(0,l.jsx)(i.h3,{id:"collision-avoidance",children:"Collision Avoidance"}),"\n",(0,l.jsx)(i.p,{children:"Ensure safe manipulation:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Self-collision detection"}),"\n",(0,l.jsx)(i.li,{children:"Environment collision checking"}),"\n",(0,l.jsx)(i.li,{children:"Human safety protocols"}),"\n",(0,l.jsx)(i.li,{children:"Emergency stopping"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"operational-limits",children:"Operational Limits"}),"\n",(0,l.jsx)(i.p,{children:"Respect operational limits:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Joint position limits"}),"\n",(0,l.jsx)(i.li,{children:"Velocity and acceleration limits"}),"\n",(0,l.jsx)(i.li,{children:"Force/torque limits"}),"\n",(0,l.jsx)(i.li,{children:"Workspace boundaries"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,l.jsx)(i.h3,{id:"real-time-performance",children:"Real-time Performance"}),"\n",(0,l.jsx)(i.p,{children:"Optimize for real-time operation:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Efficient collision checking"}),"\n",(0,l.jsx)(i.li,{children:"Fast inverse kinematics"}),"\n",(0,l.jsx)(i.li,{children:"Low-latency control"}),"\n",(0,l.jsx)(i.li,{children:"Parallel processing"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"computational-efficiency",children:"Computational Efficiency"}),"\n",(0,l.jsx)(i.p,{children:"Balance accuracy with efficiency:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Simplified collision models"}),"\n",(0,l.jsx)(i.li,{children:"Hierarchical planning"}),"\n",(0,l.jsx)(i.li,{children:"Approximate solutions"}),"\n",(0,l.jsx)(i.li,{children:"Caching strategies"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"testing-and-validation",children:"Testing and Validation"}),"\n",(0,l.jsx)(i.h3,{id:"manipulation-testing",children:"Manipulation Testing"}),"\n",(0,l.jsx)(i.p,{children:"Test manipulation capabilities:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Grasp success rate"}),"\n",(0,l.jsx)(i.li,{children:"Placement accuracy"}),"\n",(0,l.jsx)(i.li,{children:"Task completion rate"}),"\n",(0,l.jsx)(i.li,{children:"Safety compliance"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"performance-metrics",children:"Performance Metrics"}),"\n",(0,l.jsx)(i.p,{children:"Measure manipulation performance:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Execution time"}),"\n",(0,l.jsx)(i.li,{children:"Success rate"}),"\n",(0,l.jsx)(i.li,{children:"Energy efficiency"}),"\n",(0,l.jsx)(i.li,{children:"Smoothness metrics"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"integration-with-navigation",children:"Integration with Navigation"}),"\n",(0,l.jsx)(i.p,{children:"Connect manipulation with navigation:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Mobile manipulation"}),"\n",(0,l.jsx)(i.li,{children:"Coordinated navigation-manipulation"}),"\n",(0,l.jsx)(i.li,{children:"Task allocation"}),"\n",(0,l.jsx)(i.li,{children:"Resource management"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,l.jsx)(i.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Grasp failures"}),"\n",(0,l.jsx)(i.li,{children:"Trajectory execution errors"}),"\n",(0,l.jsx)(i.li,{children:"Force control instability"}),"\n",(0,l.jsx)(i.li,{children:"Perception inaccuracies"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"debugging-strategies",children:"Debugging Strategies"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Visualization tools"}),"\n",(0,l.jsx)(i.li,{children:"Trajectory inspection"}),"\n",(0,l.jsx)(i.li,{children:"Force/torque monitoring"}),"\n",(0,l.jsx)(i.li,{children:"Control parameter tuning"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"isaac-specific-features",children:"Isaac-Specific Features"}),"\n",(0,l.jsx)(i.h3,{id:"gpu-acceleration",children:"GPU Acceleration"}),"\n",(0,l.jsx)(i.p,{children:"Leverage Isaac's GPU acceleration:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Parallel grasp evaluation"}),"\n",(0,l.jsx)(i.li,{children:"Accelerated collision checking"}),"\n",(0,l.jsx)(i.li,{children:"Real-time trajectory optimization"}),"\n",(0,l.jsx)(i.li,{children:"Deep learning inference"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"integration-with-isaac-tools",children:"Integration with Isaac Tools"}),"\n",(0,l.jsx)(i.p,{children:"Integrate with other Isaac components:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Perception pipeline integration"}),"\n",(0,l.jsx)(i.li,{children:"Navigation coordination"}),"\n",(0,l.jsx)(i.li,{children:"Simulation validation"}),"\n",(0,l.jsx)(i.li,{children:"Hardware-in-the-loop testing"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,l.jsx)(i.p,{children:"Continue to the next section to learn about synthetic data generation for perception training."})]})}function p(n={}){const{wrapper:i}={...(0,a.R)(),...n.components};return i?(0,l.jsx)(i,{...n,children:(0,l.jsx)(d,{...n})}):d(n)}},8453:(n,i,e)=>{e.d(i,{R:()=>s,x:()=>o});var l=e(6540);const a={},t=l.createContext(a);function s(n){const i=l.useContext(t);return l.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function o(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),l.createElement(t.Provider,{value:i},n.children)}}}]);