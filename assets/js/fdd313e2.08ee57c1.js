"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[991],{8453:(n,e,i)=>{i.d(e,{R:()=>r,x:()=>l});var s=i(6540);const o={},t=s.createContext(o);function r(n){const e=s.useContext(t);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),s.createElement(t.Provider,{value:e},n.children)}},9963:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>t,metadata:()=>l,toc:()=>d});var s=i(4848),o=i(8453);const t={sidebar_position:2},r="Robot Models in Simulation Environments",l={id:"module-2-digital-twin/robot-models",title:"Robot Models in Simulation Environments",description:"Overview",source:"@site/docs/docs/module-2-digital-twin/robot-models.md",sourceDirName:"module-2-digital-twin",slug:"/module-2-digital-twin/robot-models",permalink:"/docs/module-2-digital-twin/robot-models",draft:!1,unlisted:!1,editUrl:"https://github.com/abasitbaloch/Next-Gen-Humanoid-Robotics-Book/tree/main/docs/docs/module-2-digital-twin/robot-models.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Module 2: Digital Twin (Gazebo & Unity)",permalink:"/docs/module-2-digital-twin/intro"},next:{title:"Sensors and Physics Configuration",permalink:"/docs/module-2-digital-twin/sensors-physics"}},a={},d=[{value:"Overview",id:"overview",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Converting URDF for Gazebo",id:"converting-urdf-for-gazebo",level:2},{value:"Physics Properties",id:"physics-properties",level:2},{value:"Joint Configuration",id:"joint-configuration",level:2},{value:"Gazebo Plugins",id:"gazebo-plugins",level:2},{value:"Testing Robot Models",id:"testing-robot-models",level:2},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:2},{value:"Unity Alternative",id:"unity-alternative",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h1,{id:"robot-models-in-simulation-environments",children:"Robot Models in Simulation Environments"}),"\n",(0,s.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(e.p,{children:"This section covers how to integrate your robot models into simulation environments, specifically Gazebo. We'll cover the process of taking your URDF robot description and making it work properly in simulation."}),"\n",(0,s.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsx)(e.p,{children:"Before starting this section, ensure you have:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"A valid URDF model of your robot"}),"\n",(0,s.jsx)(e.li,{children:"ROS 2 Humble installed"}),"\n",(0,s.jsx)(e.li,{children:"Gazebo Harmonic installed"}),"\n",(0,s.jsx)(e.li,{children:"Basic understanding of URDF and XACRO"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"converting-urdf-for-gazebo",children:"Converting URDF for Gazebo"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo requires additional elements in your URDF file to properly simulate physics and sensors:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Example of Gazebo-specific elements --\x3e\n<gazebo reference="joint_name">\n  <axis>\n    <xyz>0 0 1</xyz>\n  </axis>\n</gazebo>\n\n<gazebo reference="link_name">\n  <mu1>0.9</mu1>\n  <mu2>0.9</mu2>\n  <material>Gazebo/Blue</material>\n</gazebo>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"physics-properties",children:"Physics Properties"}),"\n",(0,s.jsx)(e.p,{children:"Configure physics properties for realistic simulation:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Mass"}),": Ensure all links have realistic mass values"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Inertia"}),": Proper inertia tensors for stable simulation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Friction"}),": Appropriate friction coefficients for contact modeling"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Damping"}),": Viscous damping for smooth motion"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"joint-configuration",children:"Joint Configuration"}),"\n",(0,s.jsx)(e.p,{children:"Set up joints with proper limits and dynamics:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<joint name="joint_name" type="revolute">\n  <parent link="parent_link"/>\n  <child link="child_link"/>\n  <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>\n  <dynamics damping="0.1" friction="0.0"/>\n</joint>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"gazebo-plugins",children:"Gazebo Plugins"}),"\n",(0,s.jsx)(e.p,{children:"Add necessary plugins for simulation:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Joint state publisher"}),": Publishes joint states for ROS"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Robot state publisher"}),": Publishes TF transforms"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Controllers"}),": Position, velocity, or effort controllers"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sensors"}),": Camera, LIDAR, IMU, etc."]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"testing-robot-models",children:"Testing Robot Models"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Load your robot in Gazebo:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"ros2 launch gazebo_ros gazebo.launch.py\nros2 run gazebo_ros spawn_entity.py -file robot.urdf -entity robot_name\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Verify joint movements and physics behavior"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Test sensor outputs and data quality"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Robot falls through ground"}),": Check collision meshes and physics properties"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Joints behave strangely"}),": Verify joint limits and dynamics"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sensors not publishing"}),": Check plugin configuration"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Performance issues"}),": Simplify collision meshes"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"unity-alternative",children:"Unity Alternative"}),"\n",(0,s.jsx)(e.p,{children:"While Gazebo is the primary simulation environment covered in this book, Unity offers:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"More realistic graphics rendering"}),"\n",(0,s.jsx)(e.li,{children:"VR/AR integration capabilities"}),"\n",(0,s.jsx)(e.li,{children:"Different physics engine (NVIDIA PhysX)"}),"\n",(0,s.jsx)(e.li,{children:"Better visualization tools"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"However, Gazebo has better ROS 2 integration out of the box."}),"\n",(0,s.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(e.p,{children:"Continue to the next section to learn about configuring sensors and physics parameters in simulation."})]})}function h(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}}}]);