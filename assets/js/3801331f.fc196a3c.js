"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[300],{1303:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>t,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var s=i(4848),r=i(8453);const a={sidebar_position:3},l="Sensors and Physics Configuration",o={id:"module-2-digital-twin/sensors-physics",title:"Sensors and Physics Configuration",description:"Overview",source:"@site/docs/docs/module-2-digital-twin/sensors-physics.md",sourceDirName:"module-2-digital-twin",slug:"/module-2-digital-twin/sensors-physics",permalink:"/docs/module-2-digital-twin/sensors-physics",draft:!1,unlisted:!1,editUrl:"https://github.com/abasitbaloch/Next-Gen-Humanoid-Robotics-Book/tree/main/docs/docs/module-2-digital-twin/sensors-physics.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Robot Models in Simulation Environments",permalink:"/docs/module-2-digital-twin/robot-models"},next:{title:"Environment Design and Scenarios",permalink:"/docs/module-2-digital-twin/environments"}},t={},c=[{value:"Overview",id:"overview",level:2},{value:"Physics Configuration",id:"physics-configuration",level:2},{value:"Gravity and World Settings",id:"gravity-and-world-settings",level:3},{value:"Collision Properties",id:"collision-properties",level:3},{value:"Inertial Properties",id:"inertial-properties",level:3},{value:"Sensor Configuration",id:"sensor-configuration",level:2},{value:"Camera Sensors",id:"camera-sensors",level:3},{value:"Depth Sensors",id:"depth-sensors",level:3},{value:"LIDAR Sensors",id:"lidar-sensors",level:3},{value:"IMU Sensors",id:"imu-sensors",level:3},{value:"Physics Tuning",id:"physics-tuning",level:2},{value:"Real-time Performance",id:"real-time-performance",level:3},{value:"Stability",id:"stability",level:3},{value:"Sensor Calibration",id:"sensor-calibration",level:2},{value:"Intrinsic Calibration",id:"intrinsic-calibration",level:3},{value:"Extrinsic Calibration",id:"extrinsic-calibration",level:3},{value:"Validation",id:"validation",level:2},{value:"Physics Validation",id:"physics-validation",level:3},{value:"Sensor Validation",id:"sensor-validation",level:3},{value:"Common Issues",id:"common-issues",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"sensors-and-physics-configuration",children:"Sensors and Physics Configuration"}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"This section covers configuring sensors and physics parameters in your simulation environment to match real-world behavior as closely as possible."}),"\n",(0,s.jsx)(n.h2,{id:"physics-configuration",children:"Physics Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"gravity-and-world-settings",children:"Gravity and World Settings"}),"\n",(0,s.jsx)(n.p,{children:"Configure your simulation world with appropriate physics parameters:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"\x3c!-- In your .world file --\x3e\n<sdf version='1.7'>\n  <world name='default'>\n    <physics type='ode'>\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n    </physics>\n    <gravity>0 0 -9.8</gravity>\n  </world>\n</sdf>\n"})}),"\n",(0,s.jsx)(n.h3,{id:"collision-properties",children:"Collision Properties"}),"\n",(0,s.jsx)(n.p,{children:"Configure collision properties for realistic interaction:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Friction coefficients"}),": Static and dynamic friction for different surfaces"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bounce"}),": Restitution coefficients for elastic collisions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Contact surfaces"}),": Parameters for stable contact resolution"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"inertial-properties",children:"Inertial Properties"}),"\n",(0,s.jsx)(n.p,{children:"Ensure your robot's inertial properties are realistic:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Mass values should reflect real hardware"}),"\n",(0,s.jsx)(n.li,{children:"Inertia tensors should be calculated properly"}),"\n",(0,s.jsx)(n.li,{children:"Center of mass should be accurate for stable simulation"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"sensor-configuration",children:"Sensor Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"camera-sensors",children:"Camera Sensors"}),"\n",(0,s.jsx)(n.p,{children:"Configure RGB cameras with realistic parameters:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="camera_link">\n  <sensor type="camera" name="camera_sensor">\n    <update_rate>30</update_rate>\n    <camera name="head">\n      <horizontal_fov>1.3962634</horizontal_fov>\n      <image>\n        <width>640</width>\n        <height>480</height>\n        <format>R8G8B8</format>\n      </image>\n      <clip>\n        <near>0.1</near>\n        <far>100</far>\n      </clip>\n    </camera>\n    <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n      <frame_name>camera_optical_frame</frame_name>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"depth-sensors",children:"Depth Sensors"}),"\n",(0,s.jsx)(n.p,{children:"Configure depth sensors for 3D perception:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Point cloud generation parameters"}),"\n",(0,s.jsx)(n.li,{children:"Depth accuracy and noise modeling"}),"\n",(0,s.jsx)(n.li,{children:"Field of view settings"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"lidar-sensors",children:"LIDAR Sensors"}),"\n",(0,s.jsx)(n.p,{children:"Set up LIDAR sensors for navigation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="lidar_link">\n  <sensor type="ray" name="head_rplidar_sensor">\n    <pose>0 0 0 0 0 0</pose>\n    <visualize>false</visualize>\n    <update_rate>5.5</update_rate>\n    <ray>\n      <scan>\n        <horizontal>\n          <samples>360</samples>\n          <resolution>1</resolution>\n          <min_angle>-3.14159</min_angle>\n          <max_angle>3.14159</max_angle>\n        </horizontal>\n      </scan>\n      <range>\n        <min>0.1</min>\n        <max>30</max>\n        <resolution>0.01</resolution>\n      </range>\n    </ray>\n    <plugin name="gazebo_ros_head_rplidar_controller" filename="libgazebo_ros_laser.so">\n      <topic_name>scan</topic_name>\n      <frame_name>lidar_link</frame_name>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"imu-sensors",children:"IMU Sensors"}),"\n",(0,s.jsx)(n.p,{children:"Configure IMU sensors for state estimation:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Accelerometer and gyroscope parameters"}),"\n",(0,s.jsx)(n.li,{children:"Noise characteristics"}),"\n",(0,s.jsx)(n.li,{children:"Update rates"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"physics-tuning",children:"Physics Tuning"}),"\n",(0,s.jsx)(n.h3,{id:"real-time-performance",children:"Real-time Performance"}),"\n",(0,s.jsx)(n.p,{children:"Balance accuracy with performance:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Step size: Smaller for accuracy, larger for performance"}),"\n",(0,s.jsx)(n.li,{children:"Update rate: Match real-world sensor rates"}),"\n",(0,s.jsx)(n.li,{children:"Real-time factor: 1.0 for real-time simulation"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"stability",children:"Stability"}),"\n",(0,s.jsx)(n.p,{children:"Ensure simulation stability:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Proper mass and inertia values"}),"\n",(0,s.jsx)(n.li,{children:"Appropriate solver parameters"}),"\n",(0,s.jsx)(n.li,{children:"Adequate update rates for control systems"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"sensor-calibration",children:"Sensor Calibration"}),"\n",(0,s.jsx)(n.h3,{id:"intrinsic-calibration",children:"Intrinsic Calibration"}),"\n",(0,s.jsx)(n.p,{children:"Simulate camera intrinsic parameters that match real hardware:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Focal length and principal point"}),"\n",(0,s.jsx)(n.li,{children:"Distortion coefficients"}),"\n",(0,s.jsx)(n.li,{children:"Image format and resolution"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"extrinsic-calibration",children:"Extrinsic Calibration"}),"\n",(0,s.jsx)(n.p,{children:"Configure sensor positions and orientations relative to the robot:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Transform relationships between sensors and robot frames"}),"\n",(0,s.jsx)(n.li,{children:"Sensor mounting positions and angles"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"validation",children:"Validation"}),"\n",(0,s.jsx)(n.h3,{id:"physics-validation",children:"Physics Validation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Compare simulation behavior with real robot (when available)"}),"\n",(0,s.jsx)(n.li,{children:"Verify that basic movements are stable and realistic"}),"\n",(0,s.jsx)(n.li,{children:"Test contact behavior and friction"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"sensor-validation",children:"Sensor Validation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Compare sensor outputs with real hardware characteristics"}),"\n",(0,s.jsx)(n.li,{children:"Validate noise models and accuracy"}),"\n",(0,s.jsx)(n.li,{children:"Check update rates and data quality"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"common-issues",children:"Common Issues"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Simulation instability"}),": Check mass/inertia values and solver parameters"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sensor noise"}),": Adjust noise parameters to match real hardware"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance issues"}),": Reduce physics complexity or increase step size"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Drift"}),": Verify IMU and odometry parameters"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(n.p,{children:"Continue to the next section to learn about creating simulation environments and worlds."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var s=i(6540);const r={},a=s.createContext(r);function l(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);